section_env([file_top_section,pragmas([]),paper_opts(1,afourpaper),coversec([],[],[[string_esc("Christian Most Tazon")]],[],nop,nop,[]),level(0)],global_label("Práctica 1: En Binario y Hexadecimal"),[string_esc("Práctica 1: En Binario y Hexadecimal")],[show_toc(subparts),section_env([unnumbered,level(1),subfile(intro)],global_label("code"),string_esc("code"),[[],[raw_nl,[[string_esc("Documentacion de la práctica 1 de Christian Most Tazon. Esta práctica trata con operaciones de bytes y listas de bytes, siendo los bytes o una lista de 8 bits o una representacion hexadecimal de estos.")]],linebreak],[section_env([with_parent,level(2)],local_label("Usage and interface"),string_esc("Usage and interface"),cartouche(itemize_env(bullet,[[item([]),bf([string_esc("Library usage"),string_esc(":")]),linebreak,tt(string_esc(":- use_module(/home/patala/Desktop/CiaoProlog/Practica1/code.pl)."))],[item([]),bf([string_esc("Exports"),string_esc(":")]),linebreak,itemize_env(minus,[[[item([]),em([string_esc("Predicates"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("0"),string_esc("bit/1"),string_esc("bit/1")),string_esc(", ")],[idx_env(use,code,localnum_label("1"),string_esc("binary_byte/1"),string_esc("binary_byte/1")),string_esc(", ")],[idx_env(use,code,localnum_label("2"),string_esc("hexd/1"),string_esc("hexd/1")),string_esc(", ")],[idx_env(use,code,localnum_label("3"),string_esc("hex_byte/1"),string_esc("hex_byte/1")),string_esc(", ")],[idx_env(use,code,localnum_label("4"),string_esc("byte_list/1"),string_esc("byte_list/1")),string_esc(", ")],[idx_env(use,code,localnum_label("5"),string_esc("byte_convert/2"),string_esc("byte_convert/2")),string_esc(", ")],[idx_env(use,code,localnum_label("6"),string_esc("byte_list_convert/2"),string_esc("byte_list_convert/2")),string_esc(", ")],[idx_env(use,code,localnum_label("7"),string_esc("get_nth_bit_from_byte/3"),string_esc("get_nth_bit_from_byte/3")),string_esc(", ")],[idx_env(use,code,localnum_label("8"),string_esc("reverse_byte/2"),string_esc("reverse_byte/2")),string_esc(", ")],[idx_env(use,code,localnum_label("9"),string_esc("convert_binary_to_bit_list/2"),string_esc("convert_binary_to_bit_list/2")),string_esc(", ")],[idx_env(use,code,localnum_label("10"),string_esc("convert_to_bit_list/2"),string_esc("convert_to_bit_list/2")),string_esc(", ")],[idx_env(use,code,localnum_label("11"),string_esc("convert_to_binary_list/2"),string_esc("convert_to_binary_list/2")),string_esc(", ")],[idx_env(use,code,localnum_label("12"),string_esc("convert_to_byte_list/2"),string_esc("convert_to_byte_list/2")),string_esc(", ")],[idx_env(use,code,localnum_label("13"),string_esc("convert_binary_list_to_hex/2"),string_esc("convert_binary_list_to_hex/2")),string_esc(", ")],[idx_env(use,code,localnum_label("14"),string_esc("displace_bit_list_to_left/2"),string_esc("displace_bit_list_to_left/2")),string_esc(", ")],[idx_env(use,code,localnum_label("15"),string_esc("displace_bit_list_to_right/2"),string_esc("displace_bit_list_to_right/2")),string_esc(", ")],[idx_env(use,code,localnum_label("16"),string_esc("byte_list_clsh/2"),string_esc("byte_list_clsh/2")),string_esc(", ")],[idx_env(use,code,localnum_label("17"),string_esc("byte_list_crsh/2"),string_esc("byte_list_crsh/2")),string_esc(", ")],[idx_env(use,code,localnum_label("18"),string_esc("byte_xor/3"),string_esc("byte_xor/3")),string_esc(", ")],[idx_env(use,code,localnum_label("19"),string_esc("bit_xor/3"),string_esc("bit_xor/3")),string_esc(".")]],raw_nl]],nop,nop,nop,nop,nop],nop])],nop,nop,nop,nop]))),[],[],section_env([with_parent,level(2)],local_label("Documentation on exports"),string_esc("Documentation on exports"),[[defpred(local_label("bit/1"),pred,"PREDICATE",bit/1,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("bit(+BinaryValue)")),string_esc([])],raw_nl],[string_esc("define los valores posibles de un bit como b(0) o b(1)")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("binary_byte/1"),pred,"PREDICATE",binary_byte/1,[],[[string_esc("Se usa para comprobar si un byte está escrito en formato binario")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("binary_byte(+[B1,B2,B3,B4,B5,B6,B7,B8])")),string_esc([])],raw_nl],[string_esc("define un byte binario como una lista de 8 bits")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("hexd/1"),pred,"PREDICATE",hexd/1,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("hexd(+HexValue)")),string_esc([])],raw_nl],[string_esc("define la representacion de valores hexadecimales como h(0), ..., h(f)")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("hex_byte/1"),pred,"PREDICATE",hex_byte/1,[],[[string_esc("Se usa para comprobar si un byte está escrito en formato hexadecimal")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("hex_byte(+[NIBBLE1,NIBBLE2])")),string_esc([])],raw_nl],[string_esc("define un byte hexadecimal como una lista de dos nibbles / digitos hexadecimales")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("byte_list/1"),pred,"PREDICATE",byte_list/1,[],[[string_esc("Predicado usado para comprobar si una lista es una lista de bytes validos")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("byte_list(+LISTA_BYTES)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("LISTA_BYTES")]),string_esc(" "),string_esc("es una lista formada por bytes, ya sean hexadecimales o binarios")],assrtprops([],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_list([])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_list([])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("20"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_list([[b(0),b(1),b(0),b(1),b(0),b(1),b(1),b(0)]])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_list([[b(0),b(1),b(0),b(1),b(0),b(1),b(1),b(0)]])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("21"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_list([[h(1),h(c)]])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_list([[h(1),h(c)]])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("22"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_list([[b(1),b(1),b(0),b(1),b(0),b(1),b(0),b(0)],[h(c),h(1)]])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_list([[b(1),b(1),b(0),b(1),b(0),b(1),b(0),b(0)],[h(c),h(1)]])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("23"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("byte_convert/2"),pred,"PREDICATE",byte_convert/2,[],[[string_esc("Predicado usado para comprobar si dos bytes, uno binario y otro decimal, son equivalentes, y también usado para cambiar el formato de un byte")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("byte_convert(+ByteHexadecimal,+ByteBinario)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("ByteHexadecimal")]),string_esc(" "),string_esc("y "),var([string_esc("ByteBinario")]),string_esc(" "),string_esc("son equivalentes")],assrtprops([],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_convert([h(0),h(0)],[b(0),b(0),b(0),b(0),b(0),b(0),b(0),b(0)])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_convert([h(0),h(0)],[b(0),b(0),b(0),b(0),b(0),b(0),b(0),b(0)])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("24"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_convert([h(f),h(f)],[b(1),b(1),b(1),b(1),b(1),b(1),b(1),b(1)])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_convert([h(f),h(f)],[b(1),b(1),b(1),b(1),b(1),b(1),b(1),b(1)])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("25"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_convert([h(1),h(2)],[b(0),b(0),b(0),b(1),b(0),b(0),b(1),b(0)])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_convert([h(1),h(2)],[b(0),b(0),b(0),b(1),b(0),b(0),b(1),b(0)])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("26"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_convert([h(3),h(4)],[b(0),b(0),b(1),b(1),b(0),b(1),b(0),b(0)])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_convert([h(3),h(4)],[b(0),b(0),b(1),b(1),b(0),b(1),b(0),b(0)])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("27"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_convert([h(5),h(6)],[b(0),b(1),b(0),b(1),b(0),b(1),b(1),b(0)])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_convert([h(5),h(6)],[b(0),b(1),b(0),b(1),b(0),b(1),b(1),b(0)])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("28"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("byte_list_convert/2"),pred,"PREDICATE",byte_list_convert/2,[],[[string_esc("Predicado usado para transformar una lista de bytes de un formato al otro formato. Se usa en predicados que tienen que realizar operaciones binarias sobre bytes que pueden ser hexadecimales")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("byte_list_convert(+HexadecimalByteList,+BinaryByteList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("HexadecimalByteList")]),string_esc(" "),string_esc("y "),var([string_esc("BinaryByteList")]),string_esc(" "),string_esc("son listas de bytes equivalentes")],assrtprops([],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("byte_list_convert([[h(0),h(1)],[h(f),h(e)]],[[b(0),b(0),b(0),b(0),b(0),b(0),b(0),b(1)],[b(1),b(1),b(1),b(1),b(1),b(1),b(1),b(0)]])")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("byte_list_convert([[h(0),h(1)],[h(f),h(e)]],[[b(0),b(0),b(0),b(0),b(0),b(0),b(0),b(1)],[b(1),b(1),b(1),b(1),b(1),b(1),b(1),b(0)]])")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("29"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("get_nth_bit_from_byte/3"),pred,"PREDICATE",get_nth_bit_from_byte/3,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("get_nth_bit_from_byte(+Index,+Byte,+NthBit)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("NthBit")]),string_esc(" "),string_esc("es el bit numero "),var([string_esc("Index")]),string_esc(" "),string_esc("del byte "),var([string_esc("Byte")]),string_esc(". Se cuenta desde el byte menos significativo (desde la derecha)")],assrtprops([],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("get_nth_bit_from_byte(0,[h(0),h(0)],b(0))")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("get_nth_bit_from_byte(0,[h(0),h(0)],b(0))")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("30"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("get_nth_bit_from_byte(s(0),[h(0),h(0)],b(0))")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("get_nth_bit_from_byte(s(0),[h(0),h(0)],b(0))")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("31"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("get_nth_bit_from_byte(0,[h(f),h(f)],b(0))")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("get_nth_bit_from_byte(0,[h(f),h(f)],b(0))")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("32"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("get_nth_bit_from_byte(0,[h(f),h(f)],b(1))")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("get_nth_bit_from_byte(0,[h(f),h(f)],b(1))")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("33"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Example:",[[string_esc([]),tt(string_esc("get_nth_bit_from_byte(s(s(s(0))),[b(1),b(1),b(1),b(1),b(0),b(1),b(1),b(1)],b(0))")),string_esc([])],raw_nl],[],assrtprops([],[],[],[[item([]),em(string_esc("The following properties should hold globally:"))],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("get_nth_bit_from_byte(s(s(s(0))),[b(1),b(1),b(1),b(1),b(0),b(1),b(1),b(1)],b(0))")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("34"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("reverse_byte/2"),pred,"PREDICATE",reverse_byte/2,[],[[string_esc("Da la vuelta a un byte, invirtiendo la significancia de cada bit, y lo devuelve en un parametro de salida.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("reverse_byte(+Byte,+ReversedByte)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("ReversedByte")]),string_esc(" "),string_esc("es "),var([string_esc("Byte")]),string_esc(" "),string_esc("dado la vuelta")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("convert_binary_to_bit_list/2"),pred,"PREDICATE",convert_binary_to_bit_list/2,[],[[string_esc("Es una funcion auxiliar de 'convert_to_bit_list/2' que solo acepta bytes en formato binario. Saca los bits de los bytes de una lista de bytes y devuelve una lista de estos bits. Se puede entender como que 'unifica' los bits de una lista de bytes en una única entidad para facilitar operaciones a nivel bit sobre un conjunto seguido de bytes.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("convert_binary_to_bit_list(+ByteList,+BitList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("BitList")]),string_esc(" "),string_esc("es una lista de los bits que forman los bytes de la lista de bytes binarios "),var([string_esc("ByteList")])],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("convert_to_bit_list/2"),pred,"PREDICATE",convert_to_bit_list/2,[],[[string_esc("Saca los bits de los bytes de una lista de bytes y devuelve una lista de estos bits. Se puede entender como que 'unifica' los bits de una lista de bytes en una única entidad para facilitar operaciones a nivel bit sobre un conjunto seguido de bytes. Usa la funcion convert_binary_to_bit_list/2 y convert_to_binary_list/2 para transformar listas de cualquier formato de byte a bits.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("convert_to_bit_list(+ByteList,+BitList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("BitList")]),string_esc(" "),string_esc("es una lista de los bits que forman los bytes de la lista de bytes en cualquier formato "),var([string_esc("ByteList")])],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("convert_to_binary_list/2"),pred,"PREDICATE",convert_to_binary_list/2,[],[[string_esc("Transforma una lista de bytes a una lista de bytes en formato binario. Para hacer esto transforma bytes de formato hexadecimal a decimal y copia bytes que ya están en formato binario. Debido a esto, la función devuelve siempre lo mismo sin necesidad de revisar que la lista a transformar no está ya en formato binario.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("convert_to_binary_list(+ByteList,+BinaryByteList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("BinaryByteList")]),string_esc(" "),string_esc("es una lista de bytes en formato binario equivalentes a la lista de bytes "),var([string_esc("ByteList")])],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("convert_to_byte_list/2"),pred,"PREDICATE",convert_to_byte_list/2,[],[[string_esc("Junta los bits de BitList en grupos de 8 bits, formando bytes binarios, y devuelve una lista de estos bytes")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("convert_to_byte_list(+BitList,+ByteList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("ByteList")]),string_esc(" "),string_esc("es una lista de bytes con los mismos bits que "),var([string_esc("BitList")]),string_esc(", en el mismo orden")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("convert_binary_list_to_hex/2"),pred,"PREDICATE",convert_binary_list_to_hex/2,[],[[string_esc("Transforma el formato de los bytes de una lista de bytes al otro. Es util para cuando hay que realizar operaciones binarias sobre listas de bytes en formato hexadecimal.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("convert_binary_list_to_hex(+BinaryByteList,+HexadecimalByteList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("HexadecimalByteList")]),string_esc(" "),string_esc("es una lista de bytes en formato hexadecimal equivalente a la lista de bytes en formato binario "),var([string_esc("BinaryByteList")]),string_esc(" ")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("displace_bit_list_to_left/2"),pred,"PREDICATE",displace_bit_list_to_left/2,[],[[string_esc("Produce un desplazamiento logico a la izquierda de una lista de bits. Mueve el primer bit al final de la lista.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("displace_bit_list_to_left(+BitList,+DisplacedList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("DisplacedList")]),string_esc(" "),string_esc("es una lista de bits equivalente a "),var([string_esc("BitList")]),string_esc(" "),string_esc("tras un desplazamiento lógico a la izquierda.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("displace_bit_list_to_right/2"),pred,"PREDICATE",displace_bit_list_to_right/2,[],[[string_esc("Produce un desplazamiento logico a la derecha de una lista de bits. Mueve el ultimo bit al principio de la lista.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("displace_bit_list_to_right(+BitList,+DisplacedList)")),string_esc([])],raw_nl],[string_esc("Es cierto si "),var([string_esc("DisplacedList")]),string_esc(" "),string_esc("es una lista de bits equivalente a "),var([string_esc("BitList")]),string_esc(" "),string_esc("tras un desplazamiento lógico a la derecha.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("byte_list_clsh/2"),pred,"PREDICATE",byte_list_clsh/2,[],[[string_esc("Produce un desplazamiento lógico a la izquierda a nivel bit de la lista de bytes ByteList. El resultado mantiene el formato de bytes de la entrada, pero la lista tiene que estar formada por bytes de un único tipo de formato.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("byte_list_clsh(+ByteList,+ByteListLeftShift)")),string_esc([])],raw_nl],[string_esc("Es cierto si la lista de bytes en cualquier formato "),var([string_esc("ByteListLeftShift")]),string_esc(" "),string_esc("es "),var([string_esc("ByteList")]),string_esc(" "),string_esc("tras un desplazamiento lógico a la izquierda a nivel bit.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("byte_list_crsh/2"),pred,"PREDICATE",byte_list_crsh/2,[],[[string_esc("Produce un desplazamiento lógico a la derecha a nivel bit de la lista de bytes ByteList. El resultado mantiene el formato de bytes de la entrada, pero la lista tiene que estar formada por bytes de un único tipo de formato.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("byte_list_crsh(+ByteList,+ByteListRightShift)")),string_esc([])],raw_nl],[string_esc("Es cierto si la lista de bytes en cualquier formato "),var([string_esc("ByteListRightShift")]),string_esc(" "),string_esc("es "),var([string_esc("ByteList")]),string_esc(" "),string_esc("tras un desplazamiento lógico a la derecha a nivel bit.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("byte_xor/3"),pred,"PREDICATE",byte_xor/3,[],[[string_esc("Realiza la operacion 'XOR' entre dos bytes en cualquier formato y devuelve el resultado de la operacion en un parametro de salida, mantendiendo el formato de los bytes. Todos los bytes tienen que tener el mismo formato.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("byte_xor(+Byte1,+Byte2,+ResultByte)")),string_esc([])],raw_nl],[string_esc("devuelve cierto si "),var([string_esc("ResultByte")]),string_esc(" "),string_esc("es el byte resultante de la operación 'XOR' entre los bytes "),var([string_esc("Byte1")]),string_esc(" "),string_esc("y "),var([string_esc("Byte2")])],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("bit_xor/3"),pred,"PREDICATE",bit_xor/3,[],[[string_esc("Realiza la operacion lógica 'XOR' entre dos bits y devuelve el bit resultante. Este predicado define la tabla lógica de la operación 'XOR'.")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("bit_xor(+Bit1,+Bit2,+ResultBit)")),string_esc([])],raw_nl],[string_esc("devuelve cierto si "),var([string_esc("ResultBit")]),string_esc(" "),string_esc("es el but resultante de la operación 'XOR' entre los bit "),var([string_esc("Bit1")]),string_esc(" "),string_esc("y "),var([string_esc("Bit2")])],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl]]),[],[],section_env([with_parent,level(2)],local_label("Documentation on imports"),string_esc("Documentation on imports"),[string_esc("This module has the following direct dependencies:"),itemize_env(minus,[[item([]),em([string_esc("Application modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("35"),string_esc("unittest"),string_esc("unittest")),string_esc(".")]],raw_nl]],nop,nop,[item([]),em([string_esc("Internal (engine) modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("36"),string_esc("term_basic"),string_esc("term_basic")),string_esc(", ")],[idx_env(use,code,localnum_label("37"),string_esc("basiccontrol"),string_esc("basiccontrol")),string_esc(", ")],[idx_env(use,code,localnum_label("38"),string_esc("debugger_support"),string_esc("debugger_support")),string_esc(", ")],[idx_env(use,code,localnum_label("39"),string_esc("basic_props"),string_esc("basic_props")),string_esc(".")]],raw_nl]],[item([]),em([string_esc("Packages"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("40"),string_esc("pure"),string_esc("pure")),string_esc(", ")],[idx_env(use,code,localnum_label("41"),string_esc("initial"),string_esc("initial")),string_esc(", ")],[idx_env(use,code,localnum_label("42"),string_esc("condcomp"),string_esc("condcomp")),string_esc(", ")],[idx_env(use,code,localnum_label("43"),string_esc("assertions"),string_esc("assertions")),string_esc(", ")],[idx_env(use,code,localnum_label("44"),string_esc("assertions/assertions_basic"),string_esc("assertions/assertions_basic")),string_esc(", ")],[idx_env(use,code,localnum_label("45"),string_esc("regtypes"),string_esc("regtypes")),string_esc(".")]],raw_nl]]])])]])]).